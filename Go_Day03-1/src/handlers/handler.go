package handlers

import (
	"encoding/json"
	"fmt"
	"github.com/elastic/go-elasticsearch/v7"
	"github.com/golang-jwt/jwt/v5"
	"net/http"
	"src/getter"
	"src/types"
	"strconv"
	"strings"
)

type DataBase string

type Store interface {
	GetPlaces(limit int, offset int) ([]types.Place, int, error)
	GetPlacesNear(lat, lon float64) ([]types.Place, int, error)
}

func GetAllRestorans(cli Store) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "%s", types.Head)

		page, err := strconv.Atoi(r.URL.String()[7:])
		if err != nil || page < 0 {
			page = 1
			fmt.Fprintf(w, "<div> Invalid 'page' value: '%s'</div>", err)
			w.WriteHeader(http.StatusBadRequest)
		} else {
			restorans, _, _ := cli.GetPlaces(10, page*10)
			fmt.Fprintf(w, "%s", strings.Join(getter.RestoransHTTP(restorans), ""))
		}

		fmt.Fprintf(w, "</ul>\n"+
			"<a href=\"/?page=%d\">Previous</a>\n"+
			"<a href=\"/?page=%d\">Next</a>\n"+
			"<a href=\"/?page=1364\">Last</a>\n"+
			"</body>\n"+
			"</html>", page-1, page+1)
	}
}
func ApiHandler(cli Store) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {

		page, err := strconv.Atoi(r.URL.Query().Get("page"))

		if err != nil || page < 0 {
			fmt.Fprintf(w, "{\n    \"error\": \"Invalid 'page' value: '%s'\"\n}", err)
			w.WriteHeader(http.StatusBadRequest)
			return
		}
		restorans, _, _ := cli.GetPlaces(10, page*10)
		fmt.Fprintf(w, "%s", getter.RestorasJSON(restorans, page))

	}
}

func getLocation(url string) (lat, lon float64, err error) {
	lat, err = strconv.ParseFloat(url[19:strings.Index(url, "&")], 10)
	lon, err = strconv.ParseFloat(url[strings.Index(url, "&")+5:], 10)
	if err != nil {
		return 0, 0, err
	}
	return
}
func GetNearApi(cli Store) http.HandlerFunc {

	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		lat, lon, err := getLocation(r.URL.String())
		if err != nil {
			fmt.Fprintf(w, "{\n    \"error\": \"Invalid 'page' value: 'foo'\"\n}")
		} else {
			restorans, _, _ := cli.GetPlacesNear(lat, lon)
			fmt.Fprintf(w, "%s", getter.RestoransNear(restorans))
		}
	}
}

func GetJWT(key string) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")

		key := []byte(key)
		token := jwt.New(jwt.SigningMethodHS256)

		bearerToken, err := token.SignedString(key)

		if err != nil {
			http.Error(w, "sign token error", http.StatusInternalServerError)
			return
		}

		tokenMode := types.TokenJWT{Token: bearerToken}
		res, err := json.MarshalIndent(tokenMode, "", "    ")

		if err != nil {
			http.Error(w, "encode error", http.StatusInternalServerError)
			return
		}

		fmt.Fprintf(w, string(res))
	}
}
func CheckJWT(secretKey string, next http.HandlerFunc) http.HandlerFunc {
	return func(writer http.ResponseWriter, request *http.Request) {

		writer.Header().Set("Content-Type", "application/json")

		authHeader := request.Header.Get("Authorization")
		fmt.Println(authHeader)
		if authHeader == "" {
			writer.WriteHeader(http.StatusUnauthorized)
			json.NewEncoder(writer).Encode(map[string]string{
				"error": fmt.Sprintf("no access"),
			})
			return
		}

		gotToken := strings.TrimPrefix(authHeader, "Bearer ")

		_, err := jwt.Parse(gotToken, func(token *jwt.Token) (interface{}, error) {

			_, ok := token.Method.(*jwt.SigningMethodHMAC)
			if !ok {
				return nil, fmt.Errorf("Unexpected signing method: %v", token.Header["alg"])
			}

			return []byte(secretKey), nil
		})
		if err != nil {

			writer.WriteHeader(http.StatusUnauthorized)
			json.NewEncoder(writer).Encode(map[string]string{
				"error": fmt.Sprintf("Token is shit"),
			})
			return
		}
		next(writer, request)
		return
	}
}
func (s DataBase) GetPlacesNear(lat, lon float64) ([]types.Place, int, error) {
	var buf types.AutoGenerated
	var rest types.Place
	result := make([]types.Place, 0, 3)
	var err error
	es, err := elasticsearch.NewDefaultClient()

	if err != nil {
		return nil, 0, err
	}

	mapping := `
{
		"sort": [
				{
						"_geo_distance": {
								"location": {
										"lat": ` + fmt.Sprintf("%f", lat) + `,
										"lon": ` + fmt.Sprintf("%f", lon) + `
								},
								"order": "asc",
								"unit": "km",
								"mode": "min",
								"distance_type": "arc",
								"ignore_unmapped": true
						}
				}
		]
}
	`
	for i := 0; i < 3; i++ {
		restorans, err := es.Search(
			es.Search.WithIndex("places"),
			es.Search.WithPretty(),
			es.Search.WithSize(1),
			es.Search.WithFrom(i),
			es.Search.WithBody(strings.NewReader(mapping)),
		)
		if err != nil {
			return nil, 0, err
		}

		str := restorans.String()[9:]

		err = json.Unmarshal([]byte(str), &buf)

		if err != nil {
			return nil, 0, err
		}

		for _, data := range buf.Hits.Hits {
			rest.Name = data.Source.Name
			rest.Address = data.Source.Address
			rest.Phone = data.Source.Phone
			rest.Location.Lon = data.Source.Location.Lon
			rest.Location.Lat = data.Source.Location.Lat
			result = append(result, rest)
		}
	}

	return result, len(result), nil
}
func (s DataBase) GetPlaces(limit int, offset int) ([]types.Place, int, error) {
	var buf types.AutoGenerated
	var rest types.Place
	result := make([]types.Place, 0, limit)
	var err error
	es, err := elasticsearch.NewDefaultClient()

	if err != nil {
		return nil, 0, err
	}

	for i := 0; i < limit; i++ {
		restorans, _ := es.Search(
			es.Search.WithIndex("places"),
			es.Search.WithPretty(),
			es.Search.WithSize(1),
			es.Search.WithFrom(offset+i),
		)

		str := restorans.String()[9:]

		err = json.Unmarshal([]byte(str), &buf)

		if err != nil {
			return nil, 0, err
		}

		for _, data := range buf.Hits.Hits {
			rest.Name = data.Source.Name
			rest.Address = data.Source.Address
			rest.Phone = data.Source.Phone
			rest.Location.Lon = data.Source.Location.Lon
			rest.Location.Lat = data.Source.Location.Lat
			result = append(result, rest)
		}

	}

	return result, len(result), nil
}
func (s DataBase) Name() string {
	return string(s)
}
